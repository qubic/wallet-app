default_platform(:ios)
require 'dotenv'
require 'yaml'

platform :ios do

  require 'spaceship'

  lane :get_max_build_number do |options|
  
    version = options[:version]
    bundle_id = options[:bundle_id]

    app = Spaceship::ConnectAPI::App.find(bundle_id)

    UI.message("üì¶ Fetching builds for version #{version}...")

    builds = Spaceship::ConnectAPI::Build.all(
      app_id: app.id,
      sort: "-uploadedDate", # optional
      limit: 200
    )

    matching_builds = builds.select { |b| b.version == version }
    max_build = matching_builds.map { |b| b.build_number.to_i }.max || 0

    UI.success("üöÄ Max build number for version #{version} is #{max_build}")
    return max_build
  end

  desc "üîß Build and upload to TestFlight (local use only"
  lane :testflight_release do

    # Load the custom environment file
    Dotenv.load('.env.testflight_release')

    app_store_connect_api_key(
      key_id: ENV["APP_STORE_KEY_ID"],
      issuer_id: ENV["APP_STORE_ISSUER_ID"],
      key_filepath: ENV["APP_STORE_KEY_PATH"]
    )

    sh "flutter clean"
    sh "flutter pub get"
    sh "pod install"

    increment_build_number(
      build_number: latest_testflight_build_number + 1
    )
    
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      configuration: "Release",
      export_method: "app-store",
      clean: true,
      silent: false,
      export_options: {
        signingStyle: "automatic",
        manageAppVersionAndBuildNumber: true
      }
    )

    #upload_to_testflight(
     # skip_waiting_for_build_processing: true,
      #distribute_external: false
    #)
  
  end

  desc "ü§ñ CI: Build and upload silently to TestFlight"
  lane :ci_testflight_release do
    require 'xcodeproj'

    create_keychain(
      name: "ci_temp_keychain",
      password: ENV['TEMP_KEYCHAIN_PASSWORD'],
      default_keychain: true,
      unlock: true,
      timeout: 3600
    )

    xcodes(
      version: ENV["XCODE_VERSION"],
      select_for_current_build_only: true
    )

    app_store_connect_api_key(
      key_id: ENV['APP_STORE_KEY_ID'],
      issuer_id: ENV['APP_STORE_ISSUER_ID'],
      key_filepath: './AuthKey.p8',
      in_house: false
    )

    match(
      type: "appstore",
      keychain_name: "ci_temp_keychain", # Specify the keychain to use
      keychain_password: ENV['TEMP_KEYCHAIN_PASSWORD']# Password for the keychain
    )

    # Path from fastlane folder to project root
    pubspec_path = File.expand_path("../../pubspec.yaml", __dir__)

    UI.user_error!("‚ùå pubspec.yaml not found at #{pubspec_path}") unless File.exist?(pubspec_path)

    pubspec = YAML.load_file(pubspec_path)
    version_string = pubspec["version"]
    version, _ = version_string.split("+")

    # Path to the Xcode project
    xcodeproj_path = '../Runner.xcodeproj'

    # Open the Xcode project
    project = Xcodeproj::Project.open(xcodeproj_path)

    # Get the first target (usually 'Runner' for Flutter apps)
    target = project.targets.first

    # Get the bundle ID from the build settings
    bundle_id = target.build_configurations.first.build_settings['PRODUCT_BUNDLE_IDENTIFIER']

    puts "üì± App Identifier: #{bundle_id} - Version: #{version}"

    app = Spaceship::ConnectAPI::App.find(bundle_id)

    if app.nil?
      UI.user_error!("‚ùå Could not find app with bundle ID: #{bundle_id}")
    end

    builds2 = app.get_builds
    UI.message("‚úÖ Found #{builds2.count} builds total")

    # Optional: Print them
    #builds2.each do |build|
     # UI.message("Build #{build.version} (#{build.build_number})")
    #end

    builds = Spaceship::ConnectAPI::Build.all(app_id: app.id)

    #builds = Spaceship::ConnectAPI::Build.all(
     # app_id: app.id#,
     # sort: "-uploadedDate", # optional
      #limit: 200
    #)

    if builds.empty?
      UI.user_error("‚ö†Ô∏è No builds found for app: #{app.name} (#{app.bundle_id})")
      return 0
    end

    UI.message("üîç Version being checked: #{version}")

    # Log build versions for comparison
    builds.each do |b|
      #UI.message("Build version: #{b.version} Build number: #{b.app_store_connect_version}")
      #UI.message("Build attributes: #{b.attributes}")
      #UI.message("Build version: #{b.version}")
      #UI.message("Build number: #{b.build_number}")
      #UI.message("Build processed: #{b.processed}")
      #UI.message("Uploaded date: #{b.uploaded_date}")
      #UI.message("Other keys: #{b.instance_variables}")

      UI.message("Build attributes: #{b.attributes}")
      
      version = build.attributes["version"]          # e.g., 2.0.0
      build_number = build.attributes["buildNumber"] # e.g., 42
      status = build.attributes["processingState"]   # e.g., PROCESSING, VALID, etc.

      UI.message("Version: #{version}, Build Number: #{build_number}, Status: #{status}")
    end

    matching_builds = builds.select { |b| b.app_store_connect_version.strip == version.strip && !b.app_store_connect_version.nil? }

    if matching_builds.empty?
      UI.user_error("‚ö†Ô∏è No builds found for version #{version}")
      return 0
    end
  
    max_build = matching_builds.map { |b| b.version.to_i }.max || 0

    UI.success("üöÄ Max build number for version #{version} is #{max_build}")

    next_build = max_build + 1

    UI.message("üî¢ Next build number: #{next_build}")
    
    increment_build_number(
      build_number: next_build,
      skip_info_plist: true
    )

    # Build the app using build_app (this will use the incremented build number)
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      configuration: "Release",
      export_method: "app-store",
      clean: true,
      silent: false,
      verbose: true
    )

    upload_to_testflight(
      skip_waiting_for_build_processing: true,
      distribute_external: false
    )

    # Clean up keychain (optional but good practice)
    delete_keychain(
      name: "ci_temp_keychain"
    )
    
  end

end